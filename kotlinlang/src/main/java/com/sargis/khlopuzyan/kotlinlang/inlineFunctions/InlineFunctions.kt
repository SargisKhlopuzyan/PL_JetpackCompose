package com.sargis.khlopuzyan.kotlinlang.inlineFunctions

import java.util.concurrent.locks.Lock
import java.util.concurrent.locks.ReentrantLock
import kotlin.system.measureTimeMillis

fun main() {
    val timeInMs1 = measureTimeMillis {
        val reentrantLock = ReentrantLock()
        val result = lookInline(reentrantLock) {
            foo()
            return // OK: the lambda is inlined
        }
        println("result1: $result")
    }
    println("timeInMs1: $timeInMs1")

    val timeInMs2 = measureTimeMillis {
        val reentrantLock = ReentrantLock()
        val result = lookInline(reentrantLock) {
            foo()
            return // ERROR: cannot make `foo` return here as lambda marked as noinline
        }
        println("result2: $result")
    }
    println("timeInMs2: $timeInMs2")

    fooInlinedNotInlined(
        inlined = {
            /**
             * Such returns (located in a lambda, but exiting the enclosing function) are called non-local returns.
             * */
            return // OK: the lambda is inlined
        },
        notInlined = {
//            return // ERROR: cannot make `foo` return here
        },
        crossInlined = {
//            return // ERROR: cannot make `foo` return here
        }
    )
}

inline fun fooInlinedNotInlined(
    inlined: () -> Unit, //lambda in inline function will will be replaced with generated byte code in call side
    noinline notInlined: () -> Unit, // will not inline the lambda
    crossinline crossInlined: () -> Unit, // return from lambda is not possible
) {

}

fun <T> look(lock: Lock, body: () -> T): T {
    lock.lock()
    try {
        return body()
    } finally {
        lock.unlock()
    }
}


//inline fun <T> lookInline(lock: Lock, noinline body: () -> T): T {
inline fun <T> lookInline(lock: Lock, body: () -> T): T {
    lock.lock()
    try {
        return body()
    } finally {
        lock.unlock()
    }
}

fun foo(): Int {
    println("Inside foo()")
    return 17
}